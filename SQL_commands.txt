###########################################
########## ADVANCED SQL COMMANDS ##########
###########################################

- EXTRACT: a sub-component of a data type colum
    SELECT EXTRACT({YEAR|MONTH|DAY|WEEK|QUARTER} FROM date_col)
    FROM table
- AGE: return the current age of a timestamp type colum
    SELECT AGE(data_col)
    FROM table
- TO_CHAR: covert data type colum to a specified text formatting
    SELECT TO_CHAR(data_col, 'dd-mm-yyyy')
    FROM table

#############################################
########## CONDITIONAL EXPRESSIONS ##########
#############################################

- CASE: correspond to the IF/ELSE statements
    SELECT col_condition
    CASE 
        WHEN (condition_1) THAN result_1
        WHEN (condition_2) THAN result_2
        ...
        ELSE other_result
    END AS col_name
    FROM table
    
    :: CASE expression variant: evaluate the single value for equality
    SELECT
    SUM(CASE {expression|col_name}
            WHEN n THAN 1
            ELSE 0
        END) AS col_name
    FROM table

    --------------------------
    E.G.:
    SUM(CASE rental_rate
            WHEN 0.99 THAN 1
            ELSE 0
        END) AS bargains
    --------------------------
- COALESCE: replace NULL with the desired value. 
    SELECT (col_1 - COALESCE(col_2,0))
    FROM table
- CAST: convert from one data type into another
    SELECT CAST('5' AS INTEGER)
    FROM table
- NULLIF: NULLIF(arg_1, arg_2) return NULL if arg_1 = arg_2 otherwise arg_1
NB.: useful to return NULL if the denominator is equal to 0 in a division
    SELECT (col_1 / NULLIF(col_2, 0)) AS some_ratio
    FROM table

################################
########## PROCEDURES ##########
################################

- VIEW: is a database object (virtual table - does not store data pysically only the query)
It a combination of tables and conditions used quite often.
+ You can also also alter and update existing views
    
    :: to create a view ...
    CREATE VIEW view_name AS
    --- the query ---
    SELECT columns
    FROM table
    ...

    :: to call it afterwards ...
    SELECT *
    FROM view_name

    :: to modify it ...
    CREATE OR REPLACE VIEW view_name AS
    --- the new query ---
    SELECT columns
    FROM table
    ...

    :: to remove a view ...
    DROP VIEW view_name
    DROP VIEW IF EXISTS view_name

    :: rename the view ...
    ALTER VIEW view_name RENAME TO new_view_name

######################################
########## WINDOW FUNCTIONS ##########
######################################

Window functions allow you to include aggregate calculations in your
queries, WITHOUT otherwise changing the output in any way.

The aggregate calculation is simple tacked on to the query as and
additional column.

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
================================================
  AGGREGATE FUN([column]) **OVER()**
================================================
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

--YTD Sales Via Aggregate Query:

SELECT

      [Total YTD Sales] = SUM(SalesYTD)
      ,[Max YTD Sales] = MAX(SalesYTD)

FROM AdventureWorks2019.Sales.SalesPerson



--YTD Sales With OVER:

SELECT BusinessEntityID
      ,TerritoryID
      ,SalesQuota
      ,Bonus
      ,CommissionPct
      ,SalesYTD
	  ,SalesLastYear
      ,[Total YTD Sales] = SUM(SalesYTD) OVER()
      ,[Max YTD Sales] = MAX(SalesYTD) OVER()
      ,[% of Best Performer] = SalesYTD/MAX(SalesYTD) OVER()

FROM AdventureWorks2019.Sales.SalesPerson

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
================================================
  OVER(**PARTITION BY** [column|s]) 
================================================
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

It is possible to group these calculations, just like we can with 
aggregate queries, using PARTITION.

PARTITION BY allows us to compute aggregate totals for groups
within our data, while still retaining row-level detail

PARTITION BY assign each row of your query output to a group,
without collapsing your data into fewer rows as with GROUP BY


>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

--Sum of line totals, grouped by ProductID AND OrderQty, in an aggregate query

SELECT
	ProductID,
	OrderQty,
	LineTotal = SUM(LineTotal)

FROM AdventureWorks2019.Sales.SalesOrderDetail

GROUP BY
	ProductID,
	OrderQty

ORDER BY 1,2 DESC



--Sum of line totals via OVER with PARTITION BY

SELECT
	ProductID,
	SalesOrderID,
	SalesOrderDetailID,
	OrderQty,
	UnitPrice,
	UnitPriceDiscount,
	LineTotal,
	ProductIDLineTotal = SUM(LineTotal) OVER(PARTITION BY ProductID, OrderQty)

FROM AdventureWorks2019.Sales.SalesOrderDetail

ORDER BY ProductID, OrderQty DESC

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
================================================
  **ROW_NUMBER()** OVER(PARTITION BY [column|s] ORDER BY [column|s])
================================================
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

ROW_NUMBER() give us the ability to rank records within our data.

These ranking can either be applied across the entire query output, 
or to partitioned groups within it. 

It uses brute force to deal with ties returning always a unique 
sequencial series of ranking. 

If you are trying to pick exactly one record from each partition
group - either the first or last - use ROW_NUMBER()


>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

--Ranking all records within each group of sales order IDs

SELECT
	SalesOrderID,
	SalesOrderDetailID,
	LineTotal,
	ProductIDLineTotal = SUM(LineTotal) OVER(PARTITION BY SalesOrderID),
	Ranking = ROW_NUMBER() OVER(PARTITION BY SalesOrderID ORDER BY LineTotal DESC)

FROM AdventureWorks2019.Sales.SalesOrderDetail

ORDER BY
SalesOrderID




--Ranking ALL records by line total - no groups!

SELECT
	SalesOrderID,
	SalesOrderDetailID,
	LineTotal,
	ProductIDLineTotal = SUM(LineTotal) OVER(PARTITION BY SalesOrderID),
	Ranking = ROW_NUMBER() OVER(ORDER BY LineTotal DESC)

FROM AdventureWorks2019.Sales.SalesOrderDetail

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
================================================
  **RANK()** OVER(PARTITION BY [column|s] ORDER BY [column|s])      
  **DENSE_RANK()** OVER(PARTITION BY [column|s] ORDER BY [column|s]) 
================================================
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

RANK() assign the same rank for ties and skip the sequence ahead based
on how many ties there are. So, the next number in the sequence is a 
reflection of that number position in the partition group. 

DENSE_RANK() if you want ties to be explicitly identified without having breaks 
within the sequence of ranking.

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

--ROW_NUMBER, RANK, AND DENSE_RANK, compared

SELECT
	SalesOrderID,
	SalesOrderDetailID,
	LineTotal,
	Ranking = ROW_NUMBER() OVER(PARTITION BY SalesOrderID ORDER BY LineTotal DESC),
	RankingWithRank = RANK() OVER(PARTITION BY SalesOrderID ORDER BY LineTotal DESC),
	RankingWithDenseRank = DENSE_RANK() OVER(PARTITION BY SalesOrderID ORDER BY LineTotal DESC)

FROM AdventureWorks2019.Sales.SalesOrderDetail

ORDER BY SalesOrderID, LineTotal DESC

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
================================================
 **LEAD([column], [n])** OVER(PARTITION BY [column|s] ORDER BY [column|s])
 **LAG([column], [n])** OVER(PARTITION BY [column|s] ORDER BY [column|s])
================================================
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

LEAD and LAG let us grab values from subsequent or previous
records relative to the position of the "current" record in 
our data. 

They can be useful any time we want to compare a value in a given 
column to the next or previous value in the same column - but side by side, in the same row.


>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

--Basic LEAD/LAG example

SELECT
       SalesOrderID
      ,OrderDate
      ,CustomerID
      ,TotalDue
	  ,NextTotalDue = LEAD(TotalDue, 3) OVER(ORDER BY SalesOrderID)
	  ,PrevTotalDue = LAG(TotalDue, 3) OVER(ORDER BY SalesOrderID)

FROM AdventureWorks2019.Sales.SalesOrderHeader

ORDER BY SalesOrderID




--Looking forward (or backward) more than one record

SELECT
       SalesOrderID
      ,OrderDate
      ,CustomerID
      ,TotalDue
	  ,NextTotalDue = LEAD(TotalDue, 3) OVER(ORDER BY SalesOrderID)
	  ,PrevTotalDue = LAG(TotalDue, 3) OVER(ORDER BY SalesOrderID)

FROM AdventureWorks2019.Sales.SalesOrderHeader

ORDER BY SalesOrderID





--Using PARTITION with LEAD and LAG

SELECT
       SalesOrderID
      ,OrderDate
      ,CustomerID
      ,TotalDue
	  ,NextTotalDue = LEAD(TotalDue, 1) OVER(PARTITION BY CustomerID ORDER BY SalesOrderID)
	  ,PrevTotalDue = LAG(TotalDue, 1) OVER(PARTITION BY CustomerID ORDER BY SalesOrderID)

FROM AdventureWorks2019.Sales.SalesOrderHeader

ORDER BY CustomerID, SalesOrderID

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
================================================
 **FIRST_VALUE([column])** OVER(PARTITION BY [column|s] ORDER BY [column|s])
================================================
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

Operates over a window of rows defined by a PARTITION BY clause.
Returns the *first value* from the specified column within that window.
Useful for comparing the values in each row of a window with the first one.

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

--Highest and lowest line totals per customer

SELECT
	SalesOrderID,
	SalesOrderDetailID,
	LineTotal,
	Ranking = ROW_NUMBER() OVER(PARTITION BY SalesOrderID ORDER BY LineTotal DESC),
	HighestTotal = FIRST_VALUE(LineTotal) OVER(PARTITION BY SalesOrderID ORDER BY LineTotal DESC),
	LowestTotal = FIRST_VALUE(LineTotal) OVER(PARTITION BY SalesOrderID ORDER BY LineTotal)

FROM AdventureWorks2019.Sales.SalesOrderDetail

ORDER BY
	SalesOrderID, LineTotal DESC




--First/oldest order per customer

SELECT 
	CustomerID,
	OrderDate,
	TotalDue,
	FirstOrderAmt = FIRST_VALUE(TotalDue) OVER(PARTITION BY CustomerID ORDER BY OrderDate)
 
FROM AdventureWorks2019.Sales.SalesOrderHeader

ORDER BY CustomerID, OrderDate

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
================================================
 SUBQUERIES
================================================
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

Subqueries are best for straightforward, two-step queries.


>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

--Selecting the most expensive item per order in a single query

SELECT
*
FROM
    (
    SELECT
    SalesOrderID,
    SalesOrderDetailID,
    LineTotal,
    LineTotalRanking = ROW_NUMBER() OVER(PARTITION BY SalesOrderID ORDER BY LineTotal DESC)

    FROM AdventureWorks2019.Sales.SalesOrderDetail

) A

WHERE LineTotalRanking = 1

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
================================================
  AGGREGATE FUN([column]) OVER(ODER BY [column|s] **ROWS BETWEEN [n] PRECEDING AND CURRENT ROW**)
  AGGREGATE FUN([column]) OVER(ODER BY [column|s] **ROWS BETWEEN [n] PRECEDING AND [n] PRECEDING**)
  AGGREGATE FUN([column]) OVER(ODER BY [column|s] **ROWS BETWEEN [n] PRECEDING AND [n] FOLLOWING**)
================================================
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

Moving averages are used frequently because they are good at
smoothing out short term fluctuations in the overall trend of
our data. Making it easy to identify patterns and overall trends.


>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

/*Rolling 3 day total*/

SELECT
    OrderDate,
    TotalDue,
	SalesLast3Days = SUM(TotalDue) OVER(ORDER BY OrderDate ROWS BETWEEN 2 PRECEDING AND CURRENT ROW)
FROM (
	SELECT
		OrderDate,
		TotalDue = SUM(TotalDue)
	FROM
		Sales.SalesOrderHeader

	WHERE YEAR(OrderDate) = 2014

	GROUP BY
		OrderDate
) X

ORDER BY
    OrderDate



/*Rolling 3 day total, not inclusive of "current" row*/


SELECT
    OrderDate,
    TotalDue,
	SalesLast3Days = SUM(TotalDue) OVER(ORDER BY OrderDate ROWS BETWEEN 3 PRECEDING AND 1 PRECEDING)
FROM (
	SELECT
		OrderDate,
		TotalDue = SUM(TotalDue)
	FROM
		Sales.SalesOrderHeader

	WHERE YEAR(OrderDate) = 2014

	GROUP BY
		OrderDate
) X

ORDER BY
    OrderDate


/*Rolling 3 day total, spanning previous and following row*/


SELECT
    OrderDate,
    TotalDue,
	SalesLast3Days = SUM(TotalDue) OVER(ORDER BY OrderDate ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING)
FROM (
	SELECT
		OrderDate,
		TotalDue = SUM(TotalDue)
	FROM
		Sales.SalesOrderHeader

	WHERE YEAR(OrderDate) = 2014

	GROUP BY
		OrderDate
) X

ORDER BY
    OrderDate



/*Rolling 3 day average - aka, a "moving" average*/


SELECT
    OrderDate,
    TotalDue,
	SalesLast3Days = AVG(TotalDue) OVER(ORDER BY OrderDate ROWS BETWEEN 2 PRECEDING AND CURRENT ROW)
FROM (
	SELECT
		OrderDate,
		TotalDue = SUM(TotalDue)
	FROM
		Sales.SalesOrderHeader

	WHERE YEAR(OrderDate) = 2014

	GROUP BY
		OrderDate
) X

ORDER BY
    OrderDate


<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<