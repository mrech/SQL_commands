###########################################################################
########## ADVANCED SQL COMMANDS ##########################################
###########################################################################

- EXTRACT: a sub-component of a data type colum
    SELECT EXTRACT({YEAR|MONTH|DAY|WEEK|QUARTER} FROM date_col)
    FROM table
- AGE: return the current age of a timestamp type colum
    SELECT AGE(data_col)
    FROM table
- TO_CHAR: covert data type colum to a specified text formatting
    SELECT TO_CHAR(data_col, 'dd-mm-yyyy')
    FROM table

#############################################################################
########## CONDITIONAL EXPRESSIONS ##########################################
#############################################################################

- CASE: correspond to the IF/ELSE statements
    SELECT col_condition
    CASE 
        WHEN (condition_1) THAN result_1
        WHEN (condition_2) THAN result_2
        ...
        ELSE other_result
    END AS col_name
    FROM table
    
    :: CASE expression variant: evaluate the single value for equality
    SELECT
    SUM(CASE {expression|col_name}
            WHEN n THAN 1
            ELSE 0
        END) AS col_name
    FROM table

    --------------------------
    E.G.:
    SUM(CASE rental_rate
            WHEN 0.99 THAN 1
            ELSE 0
        END) AS bargains
    --------------------------
- COALESCE: replace NULL with the desired value. 
    SELECT (col_1 - COALESCE(col_2,0))
    FROM table
- CAST: convert from one data type into another
    SELECT CAST('5' AS INTEGER)
    FROM table
- NULLIF: NULLIF(arg_1, arg_2) return NULL if arg_1 = arg_2 otherwise arg_1
NB.: useful to return NULL if the denominator is equal to 0 in a division
    SELECT (col_1 / NULLIF(col_2, 0)) AS some_ratio
    FROM table

################################################################
########## PROCEDURES ##########################################
################################################################

- VIEW: is a database object (virtual table - does not store data pysically only the query)
It a combination of tables and conditions used quite often.
+ You can also also alter and update existing views
    
    :: to create a view ...
    CREATE VIEW view_name AS
    --- the query ---
    SELECT columns
    FROM table
    ...

    :: to call it afterwards ...
    SELECT *
    FROM view_name

    :: to modify it ...
    CREATE OR REPLACE VIEW view_name AS
    --- the new query ---
    SELECT columns
    FROM table
    ...

    :: to remove a view ...
    DROP VIEW view_name
    DROP VIEW IF EXISTS view_name

    :: rename the view ...
    ALTER VIEW view_name RENAME TO new_view_name

######################################################################
########## WINDOW FUNCTIONS ##########################################
######################################################################

Window functions allow you to include aggregate calculations in your
queries, WITHOUT otherwise changing the output in any way.

The aggregate calculation is simple tacked on to the query as and
additional column.

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
================================================
  AGGREGATE FUN([column]) **OVER()**
================================================
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

--YTD Sales Via Aggregate Query:

SELECT

      [Total YTD Sales] = SUM(SalesYTD)
      ,[Max YTD Sales] = MAX(SalesYTD)

FROM AdventureWorks2019.Sales.SalesPerson



--YTD Sales With OVER:

SELECT BusinessEntityID
      ,TerritoryID
      ,SalesQuota
      ,Bonus
      ,CommissionPct
      ,SalesYTD
	  ,SalesLastYear
      ,[Total YTD Sales] = SUM(SalesYTD) OVER()
      ,[Max YTD Sales] = MAX(SalesYTD) OVER()
      ,[% of Best Performer] = SalesYTD/MAX(SalesYTD) OVER()

FROM AdventureWorks2019.Sales.SalesPerson

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
================================================
  OVER(**PARTITION BY** [column|s]) 
================================================
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

It is possible to group these calculations, just like we can with 
aggregate queries, using PARTITION.

PARTITION BY allows us to compute aggregate totals for groups
within our data, while still retaining row-level detail

PARTITION BY assign each row of your query output to a group,
without collapsing your data into fewer rows as with GROUP BY


>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

--Sum of line totals, grouped by ProductID AND OrderQty, in an aggregate query

SELECT
	ProductID,
	OrderQty,
	LineTotal = SUM(LineTotal)

FROM AdventureWorks2019.Sales.SalesOrderDetail

GROUP BY
	ProductID,
	OrderQty

ORDER BY 1,2 DESC



--Sum of line totals via OVER with PARTITION BY

SELECT
	ProductID,
	SalesOrderID,
	SalesOrderDetailID,
	OrderQty,
	UnitPrice,
	UnitPriceDiscount,
	LineTotal,
	ProductIDLineTotal = SUM(LineTotal) OVER(PARTITION BY ProductID, OrderQty)

FROM AdventureWorks2019.Sales.SalesOrderDetail

ORDER BY ProductID, OrderQty DESC

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
================================================
  **ROW_NUMBER()** OVER(PARTITION BY [column|s] ORDER BY [column|s])
================================================
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

ROW_NUMBER() give us the ability to rank records within our data.

These ranking can either be applied across the entire query output, 
or to partitioned groups within it. 

It uses brute force to deal with ties returning always a unique 
sequencial series of ranking. 

If you are trying to pick exactly one record from each partition
group - either the first or last - use ROW_NUMBER()


>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

--Ranking all records within each group of sales order IDs

SELECT
	SalesOrderID,
	SalesOrderDetailID,
	LineTotal,
	ProductIDLineTotal = SUM(LineTotal) OVER(PARTITION BY SalesOrderID),
	Ranking = ROW_NUMBER() OVER(PARTITION BY SalesOrderID ORDER BY LineTotal DESC)

FROM AdventureWorks2019.Sales.SalesOrderDetail

ORDER BY
SalesOrderID




--Ranking ALL records by line total - no groups!

SELECT
	SalesOrderID,
	SalesOrderDetailID,
	LineTotal,
	ProductIDLineTotal = SUM(LineTotal) OVER(PARTITION BY SalesOrderID),
	Ranking = ROW_NUMBER() OVER(ORDER BY LineTotal DESC)

FROM AdventureWorks2019.Sales.SalesOrderDetail

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
================================================
  **RANK()** OVER(PARTITION BY [column|s] ORDER BY [column|s])      
  **DENSE_RANK()** OVER(PARTITION BY [column|s] ORDER BY [column|s]) 
================================================
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

RANK() assign the same rank for ties and skip the sequence ahead based
on how many ties there are. So, the next number in the sequence is a 
reflection of that number position in the partition group. 

DENSE_RANK() if you want ties to be explicitly identified without having breaks 
within the sequence of ranking.

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

--ROW_NUMBER, RANK, AND DENSE_RANK, compared

SELECT
	SalesOrderID,
	SalesOrderDetailID,
	LineTotal,
	Ranking = ROW_NUMBER() OVER(PARTITION BY SalesOrderID ORDER BY LineTotal DESC),
	RankingWithRank = RANK() OVER(PARTITION BY SalesOrderID ORDER BY LineTotal DESC),
	RankingWithDenseRank = DENSE_RANK() OVER(PARTITION BY SalesOrderID ORDER BY LineTotal DESC)

FROM AdventureWorks2019.Sales.SalesOrderDetail

ORDER BY SalesOrderID, LineTotal DESC

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
================================================
 **LEAD([column], [n])** OVER(PARTITION BY [column|s] ORDER BY [column|s])
 **LAG([column], [n])** OVER(PARTITION BY [column|s] ORDER BY [column|s])
================================================
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

LEAD and LAG let us grab values from subsequent or previous
records relative to the position of the "current" record in 
our data. 

They can be useful any time we want to compare a value in a given 
column to the next or previous value in the same column - but side by side, in the same row.


>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

--Basic LEAD/LAG example

SELECT
       SalesOrderID
      ,OrderDate
      ,CustomerID
      ,TotalDue
	  ,NextTotalDue = LEAD(TotalDue, 3) OVER(ORDER BY SalesOrderID)
	  ,PrevTotalDue = LAG(TotalDue, 3) OVER(ORDER BY SalesOrderID)

FROM AdventureWorks2019.Sales.SalesOrderHeader

ORDER BY SalesOrderID




--Looking forward (or backward) more than one record

SELECT
       SalesOrderID
      ,OrderDate
      ,CustomerID
      ,TotalDue
	  ,NextTotalDue = LEAD(TotalDue, 3) OVER(ORDER BY SalesOrderID)
	  ,PrevTotalDue = LAG(TotalDue, 3) OVER(ORDER BY SalesOrderID)

FROM AdventureWorks2019.Sales.SalesOrderHeader

ORDER BY SalesOrderID





--Using PARTITION with LEAD and LAG

SELECT
       SalesOrderID
      ,OrderDate
      ,CustomerID
      ,TotalDue
	  ,NextTotalDue = LEAD(TotalDue, 1) OVER(PARTITION BY CustomerID ORDER BY SalesOrderID)
	  ,PrevTotalDue = LAG(TotalDue, 1) OVER(PARTITION BY CustomerID ORDER BY SalesOrderID)

FROM AdventureWorks2019.Sales.SalesOrderHeader

ORDER BY CustomerID, SalesOrderID

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
================================================
 **FIRST_VALUE([column])** OVER(PARTITION BY [column|s] ORDER BY [column|s])
================================================
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

Operates over a window of rows defined by a PARTITION BY clause.
Returns the *first value* from the specified column within that window.
Useful for comparing the values in each row of a window with the first one.

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

--Highest and lowest line totals per customer

SELECT
	SalesOrderID,
	SalesOrderDetailID,
	LineTotal,
	Ranking = ROW_NUMBER() OVER(PARTITION BY SalesOrderID ORDER BY LineTotal DESC),
	HighestTotal = FIRST_VALUE(LineTotal) OVER(PARTITION BY SalesOrderID ORDER BY LineTotal DESC),
	LowestTotal = FIRST_VALUE(LineTotal) OVER(PARTITION BY SalesOrderID ORDER BY LineTotal)

FROM AdventureWorks2019.Sales.SalesOrderDetail

ORDER BY
	SalesOrderID, LineTotal DESC




--First/oldest order per customer

SELECT 
	CustomerID,
	OrderDate,
	TotalDue,
	FirstOrderAmt = FIRST_VALUE(TotalDue) OVER(PARTITION BY CustomerID ORDER BY OrderDate)
 
FROM AdventureWorks2019.Sales.SalesOrderHeader

ORDER BY CustomerID, OrderDate

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

################################################################
########## SUBQUERIES ##########################################
################################################################

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
================================================
 SUBQUERIES WITHIN THE FROM CLUASE
================================================
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

Subqueries are best for straightforward, two-step queries.

Each subquery is referenced by some outer query, 
which in turn can be a subquery that is referenced
again by some other outer query and so on and so 
forth until we finally reach our main query.

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

--Selecting the most expensive item per order in a single query

SELECT
*
FROM
    (
    SELECT
    SalesOrderID,
    SalesOrderDetailID,
    LineTotal,
    LineTotalRanking = ROW_NUMBER() OVER(PARTITION BY SalesOrderID ORDER BY LineTotal DESC)

    FROM AdventureWorks2019.Sales.SalesOrderDetail

) A -- subqueries from the FORM clause requires an ALIAS

WHERE LineTotalRanking = 1

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
================================================
 SCALAR SUBQUERIES
================================================
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

Use them any time you want to include aggregate calculations directly in the WHERE clause.

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

--Example 1: Scalar values

SELECT
	MAX(ListPrice)
FROM AdventureWorks2019.Production.Product

SELECT
	AVG(ListPrice)
FROM AdventureWorks2019.Production.Product




--Example 2: Scalar subqueries in the SELECT and WHERE clauses

SELECT 
	   ProductID
      ,[Name]
      ,StandardCost
      ,ListPrice
	  ,AvgListPrice = (SELECT AVG(ListPrice) FROM AdventureWorks2019.Production.Product)
	  ,AvgListPriceDiff = ListPrice - (SELECT AVG(ListPrice) FROM AdventureWorks2019.Production.Product)

FROM AdventureWorks2019.Production.Product

WHERE ListPrice > (SELECT AVG(ListPrice) FROM AdventureWorks2019.Production.Product)

ORDER BY ListPrice ASC

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
================================================
 CORRELATED SUBQUERIES
================================================
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

Correlated subqueries are subqueries that run once for each record in the main/outer query.
They then return a scalar output for each of those records.
Correlated subqueries can be used in either the SELECT and WHERE clauses. 

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
SELECT 
       SalesOrderID
      ,OrderDate
      ,SubTotal
      ,TaxAmt
      ,Freight
      ,TotalDue
	  ,MultiOrderCount = --correlated subquery
	  (
		  SELECT
		  COUNT(*)
		  FROM AdventureWorks2019.Sales.SalesOrderDetail B
		  WHERE A.SalesOrderID = B.SalesOrderID
		  AND B.OrderQty > 1
	  )

  FROM AdventureWorks2019.Sales.SalesOrderHeader A
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<


@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
================================================
  AGGREGATE FUN([column]) OVER(ODER BY [column|s] **ROWS BETWEEN [n] PRECEDING AND CURRENT ROW**)
  AGGREGATE FUN([column]) OVER(ODER BY [column|s] **ROWS BETWEEN [n] PRECEDING AND [n] PRECEDING**)
  AGGREGATE FUN([column]) OVER(ODER BY [column|s] **ROWS BETWEEN [n] PRECEDING AND [n] FOLLOWING**)
================================================
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

Moving averages are used frequently because they are good at
smoothing out short term fluctuations in the overall trend of
our data. Making it easy to identify patterns and overall trends.


>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

/*Rolling 3 day total*/

SELECT
    OrderDate,
    TotalDue,
	SalesLast3Days = SUM(TotalDue) OVER(ORDER BY OrderDate ROWS BETWEEN 2 PRECEDING AND CURRENT ROW)
FROM (
	SELECT
		OrderDate,
		TotalDue = SUM(TotalDue)
	FROM
		Sales.SalesOrderHeader

	WHERE YEAR(OrderDate) = 2014

	GROUP BY
		OrderDate
) X

ORDER BY
    OrderDate



/*Rolling 3 day total, not inclusive of "current" row*/


SELECT
    OrderDate,
    TotalDue,
	SalesLast3Days = SUM(TotalDue) OVER(ORDER BY OrderDate ROWS BETWEEN 3 PRECEDING AND 1 PRECEDING)
FROM (
	SELECT
		OrderDate,
		TotalDue = SUM(TotalDue)
	FROM
		Sales.SalesOrderHeader

	WHERE YEAR(OrderDate) = 2014

	GROUP BY
		OrderDate
) X

ORDER BY
    OrderDate


/*Rolling 3 day total, spanning previous and following row*/


SELECT
    OrderDate,
    TotalDue,
	SalesLast3Days = SUM(TotalDue) OVER(ORDER BY OrderDate ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING)
FROM (
	SELECT
		OrderDate,
		TotalDue = SUM(TotalDue)
	FROM
		Sales.SalesOrderHeader

	WHERE YEAR(OrderDate) = 2014

	GROUP BY
		OrderDate
) X

ORDER BY
    OrderDate



/*Rolling 3 day average - aka, a "moving" average*/


SELECT
    OrderDate,
    TotalDue,
	SalesLast3Days = AVG(TotalDue) OVER(ORDER BY OrderDate ROWS BETWEEN 2 PRECEDING AND CURRENT ROW)
FROM (
	SELECT
		OrderDate,
		TotalDue = SUM(TotalDue)
	FROM
		Sales.SalesOrderHeader

	WHERE YEAR(OrderDate) = 2014

	GROUP BY
		OrderDate
) X

ORDER BY
    OrderDate


<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
================================================
  EXISTS & NOT EXISTS SUBQUERY
================================================
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

EXISTS: checks to see if a match according to whatever criteria
we've set exists in another table, but it doesn't particularly 
care which record matches or how many matches there are.

For one-to-one relationships, there really isn't much of
an advantage to using EXISTS over JOIN.
However, EXISTS offers some powerful advantages when dealing
with one-to-many relationships.

Useful to apply criteria to fields from a secondary table,
but don't need to include those fields in your output.

You want to apply criteria to fields from a secondary table,
while ensuring that multiple matches in the secondary table won't
duplicate data from the primary table in your output.

You need to check a secondary table to make sure a match of
some type does NOT exist.

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

--Example 1 with one-to-many relationships

SELECT * FROM AdventureWorks2019.Sales.SalesOrderHeader WHERE SalesOrderID = 43683;

SELECT * FROM AdventureWorks2019.Sales.SalesOrderDetail WHERE SalesOrderID = 43683;

-- Example of a order without a line of at least 10.000$
SELECT * FROM AdventureWorks2019.Sales.SalesOrderDetail WHERE SalesOrderID = 43659;



--Example 2: One to many with JOIN criteria
/*
Here, we want to see all customer orders that have at least one item with 
a line total of 10.000$. However, we do not want to get to the specific item within that order. 
*/

SELECT
       A.SalesOrderID
      ,A.OrderDate
      ,A.TotalDue

FROM AdventureWorks2019.Sales.SalesOrderHeader A
	INNER JOIN AdventureWorks2019.Sales.SalesOrderDetail B
		ON A.SalesOrderID = B.SalesOrderID

WHERE B.LineTotal > 10000

ORDER BY A.SalesOrderID

-- The ABOVE solution creates unwated duplicates



--Example 3: Using EXISTS to pick only the records we need

SELECT
       A.SalesOrderID
      ,A.OrderDate
      ,A.TotalDue

FROM AdventureWorks2019.Sales.SalesOrderHeader A

WHERE EXISTS (  -- return nothing. Just check the existance of a record in another table
	SELECT -- here, you can put whatever you want
	1
	FROM AdventureWorks2019.Sales.SalesOrderDetail B
	WHERE A.SalesOrderID = B.SalesOrderID -- correlated subqueries
		AND B.LineTotal > 10000
)

-- AND A.SalesOrderID = 43659 -- To check if indeed orders without items of at least 10.000$ aren't within the output table

ORDER BY A.SalesOrderID



--Example 4: Get the opposite in a one-to-many relationships context
-- using the JOIN critiria
/*
Here, we want to see all customer orders without items with 
a line total of 10.000$. However, we do not want to get to the specific item within that order. 
*/

SELECT
       A.SalesOrderID
      ,A.OrderDate
      ,A.TotalDue
	  ,B.SalesOrderDetailID
	  ,B.LineTotal

FROM AdventureWorks2019.Sales.SalesOrderHeader A
	INNER JOIN AdventureWorks2019.Sales.SalesOrderDetail B
		ON A.SalesOrderID = B.SalesOrderID

WHERE B.LineTotal < 10000
	AND A.SalesOrderID = 43683

ORDER BY A.SalesOrderID

-- The ABOVE solution doesn't even do what we want!
-- It returns all items within a order that are less than or equal to $10.000


SELECT
*
FROM AdventureWorks2019.Sales.SalesOrderDetail

WHERE SalesOrderID = 43683

ORDER BY LineTotal DESC




--Example 6: NOT EXISTS
/*
Here, we want to see all customer orders without items with 
a line total of 10.000$. However, we do not want to get to the specific item within that order. 
*/

SELECT
       A.SalesOrderID
      ,A.OrderDate
      ,A.TotalDue

FROM AdventureWorks2019.Sales.SalesOrderHeader A

WHERE NOT EXISTS ( -- kicks the record out if exists
	SELECT
	1
	FROM AdventureWorks2019.Sales.SalesOrderDetail B
	WHERE A.SalesOrderID = B.SalesOrderID
		AND B.LineTotal > 10000
)
-- AND A.SalesOrderID = 43683 -- To check if indeed orders with items greater of 10.000$ aren't within the output table

ORDER BY A.SalesOrderID

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
================================================
  **FOR XML PATH('')** + 
  **STUFF(txt, position_stuff_into, n_trim_leading_char, stuff_into)**
================================================
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

FOR XML PATH is used to flatten multiple line outcomes in one string of values.
XML is just another way of programmatically structuring data,
where each value in our output are surounded with tag of the selected field.

We replace XML tags with text delimiters (e.i., comma or a semicolon) by
concatenating the output values with a comma. 

STUFF takes a string that we supply and then stuffs it into another string 
at a position that we specify treaming all leading characters that we do not want. 

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

-- Step 1: FOR XML PATH(''):

SELECT
LineTotal
FROM AdventureWorks2019.Sales.SalesOrderDetail A
WHERE A.SalesOrderID = 43659
FOR XML PATH('')

-- Step 2: Concatenate the outputs as text separated with commas:

SELECT
-- AS MONEY TRIM UNECESSARY TRILING ZEROS AFTER THE DECIMAL PLACE
',' + CAST(CAST(LineTotal AS MONEY) AS VARCHAR) 
FROM AdventureWorks2019.Sales.SalesOrderDetail A
WHERE A.SalesOrderID = 43659
FOR XML PATH('')

--Step 3: Using **STUFF** convert XML to a plain string and get rid of that first comma
          -- before the first item in the series.

-- outter query
SELECT
	STUFF(
		  (   -- subquery
			  SELECT
			  ',' + CAST(CAST(LineTotal AS MONEY) AS VARCHAR)
			  FROM AdventureWorks2019.Sales.SalesOrderDetail A
			  WHERE A.SalesOrderID = 43659
			  FOR XML PATH('')
		  ),
		  1,1,'')



--Step 4: Final example query

SELECT 
       SalesOrderID
      ,OrderDate
      ,SubTotal
      ,TaxAmt
      ,Freight
      ,TotalDue
	  ,LineTotals = 
		STUFF(
			  (
				  SELECT
				  ',' + CAST(CAST(LineTotal AS MONEY) AS VARCHAR)
				  FROM AdventureWorks2019.Sales.SalesOrderDetail B
				  WHERE A.SalesOrderID = B.SalesOrderID -- correlated subquery
				  FOR XML PATH('')
			  ),
			  1,1,''
		  )

FROM AdventureWorks2019.Sales.SalesOrderHeader A

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
================================================
  **PIVOT** 
================================================
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

The pivot operator lets us transpose and aggregate our data.

For each unique value in our ID column, we're 
getting a column in our pivoted output. Using an aggregate
function, we summurize all the row-wise values within 
that specific pivot output column.

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

-- outter query
SELECT
-- list of our new pivoted columns
[Accessories],
[Bikes],
[Clothing],
[Components]

FROM
-- Subquery
(
SELECT
	   ProductCategoryName = D.Name,
	   A.LineTotal

FROM AdventureWorks2019.Sales.SalesOrderDetail A
	JOIN AdventureWorks2019.Production.Product B
		ON A.ProductID = B.ProductID
	JOIN AdventureWorks2019.Production.ProductSubcategory C
		ON B.ProductSubcategoryID = C.ProductSubcategoryID
	JOIN AdventureWorks2019.Production.ProductCategory D
		ON C.ProductCategoryID = D.ProductCategoryID
) E -- we need to alias it because it is part of a subquery within a FROM clause

-- pivot keyword
PIVOT(
-- numerical field that we're trying to perform aggregations on. 
SUM(LineTotal)
-- categorical value we want to PIVOT on
-- list the columns we want to see us our output
-- since SQL isn't going to detect all the unique values by itself
FOR ProductCategoryName IN([Accessories],[Bikes],[Clothing],[Components]) 
) F


-- with * we get the same output
SELECT *

FROM
-- Subquery
(
SELECT
	   ProductCategoryName = D.Name,
	   A.LineTotal

FROM AdventureWorks2019.Sales.SalesOrderDetail A
	JOIN AdventureWorks2019.Production.Product B
		ON A.ProductID = B.ProductID
	JOIN AdventureWorks2019.Production.ProductSubcategory C
		ON B.ProductSubcategoryID = C.ProductSubcategoryID
	JOIN AdventureWorks2019.Production.ProductCategory D
		ON C.ProductCategoryID = D.ProductCategoryID
) E -- we need to alias it because it is part of a subquery within a FROM clause

-- pivot keyword
PIVOT(
-- numerical field that we're trying to perform aggregations on. 
SUM(LineTotal)
-- categorical value we want to PIVOT on
-- list the columns we want to see us our output
-- since SQL isn't going to detect all the unique values by itself
FOR ProductCategoryName IN([Accessories],[Bikes],[Clothing],[Components]) 
) F

ORDER BY 1

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

-- Make pivoted data a little more granular by adding an 
-- additional layer of grouping 

SELECT
[Order Quantity] = OrderQty, -- Business friendly alias
[Bikes],
[Clothing]

FROM
(
SELECT
/*Any column you include in your subquery here that is providing
the base data that you're ultimately pivoting, that is not being aggregated
or transposed within the PIVOT keyword below, becomes a new column in our
output. 

And our aggregated totals under each column we specified at our enlist are now 
broken out by all of the unique values in that additional column 
we have in our subquery.*/

	   ProductCategoryName = D.Name,
	   A.LineTotal,
	   A.OrderQty

FROM AdventureWorks2019.Sales.SalesOrderDetail A
	JOIN AdventureWorks2019.Production.Product B
		ON A.ProductID = B.ProductID
	JOIN AdventureWorks2019.Production.ProductSubcategory C
		ON B.ProductSubcategoryID = C.ProductSubcategoryID
	JOIN AdventureWorks2019.Production.ProductCategory D
		ON C.ProductCategoryID = D.ProductCategoryID
) E

PIVOT(
-- the field we're applying aggregation to 
SUM(LineTotal)
-- and the fields that we are transposing
FOR ProductCategoryName IN([Bikes],[Clothing])
) F

ORDER BY 1
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

#####################################################################################
########## COMMON TABLE EXPRESSIONS (CTEs) ##########################################
#####################################################################################

CTEs allow to to express multi-stage data transformations in
a linear, step by step way that is easy to follow.

CTEs are usually a superior tool versus subqueries
for any kind of analysis or data transformation process 
that requires more than two steps.

They give you a tremendous amount of flexibility because 
once you've defined one of those virtual tables, you can reference 
it in any of the virtual tables that follow.

So if I have ten virtual tables defined, my eighth virtual
table can reference my second, my third and my fourth.

Whereas with subqueries, each layer can only access the 
layer immediately beneath it.
It can't reference the subquery buried 2 or 3 layers below.

USE CTEs WHEN:
> You just need a single query output

> Querying small to medium-sized datasets.
  If a CTE is running slow, try rewriting it with 
  optimized TEMP TABLES.

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
================================================
 WITH [virtual_table_name] AS ()
================================================
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

-- 3. Refactored using CTE:

-- Virtual Tables Setup
-- Define a virtual table called: Sales
WITH Sales AS
(
-- starter inner query
SELECT 
       OrderDate
	  ,OrderMonth = DATEFROMPARTS(YEAR(OrderDate),MONTH(OrderDate),1)
      ,TotalDue
	  ,OrderRank = ROW_NUMBER() OVER(PARTITION BY DATEFROMPARTS(YEAR(OrderDate),MONTH(OrderDate),1) ORDER BY TotalDue DESC)
FROM AdventureWorks2019.Sales.SalesOrderHeader
),
-- End starter inner query
-- SELECT * FROM Sales -- check the Sales virtual table

Top10Sales AS --next virtual table
(
SELECT
OrderMonth,
Top10Total = SUM(TotalDue)
FROM Sales
WHERE OrderRank <= 10
GROUP BY OrderMonth
)

-- SELECT * FROM Top10Sales -- check the Top10Sales virtual table
-- End Virtual Tables Setup

-- Final single query that give us the final output.
SELECT
A.OrderMonth,
A.Top10Total,
PrevTop10Total = B.Top10Total

FROM Top10Sales A
	LEFT JOIN Top10Sales B
		ON A.OrderMonth = DATEADD(MONTH,1,B.OrderMonth)

ORDER BY 1

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
================================================
 RECURSIVE CTEs
================================================
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

Generating series of values with recursion, example calendar tables.

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
--Example 1: generate number series with recursive CTE


-- Create the CTE
WITH NumberSeries AS
(
SELECT
-- (1) Define an ANCOR MEMBER.
-- The first item in the series that the rest of the series build upon. 
 1 AS MyNumber

-- Stacking the numbers together
UNION  ALL

 -- (2) RECURSIVE MEMBER
 -- with a self-reference to the virtual table itself.
SELECT 
MyNumber + 1
FROM NumberSeries
-- (3) TERMINATION CONDITION
WHERE MyNumber < 100
)

-- final unique select statement
SELECT
MyNumber
FROM NumberSeries;



--Example 2: generate date series with recursive CTE

WITH Dates AS
(
SELECT
-- (1) ANCOR MEMBER.
 CAST('01-01-2021' AS DATE) AS MyDate

UNION ALL

-- (2) RECURSIVE MEMBER
SELECT
DATEADD(DAY, 1, MyDate)
FROM Dates
-- (3) TERMINATION CONDITION
WHERE MyDate < CAST('12-31-2021' AS DATE)
)

SELECT
MyDate

FROM Dates

-- To overwrite the maximum recursion limits of 100
OPTION (MAXRECURSION 365)


<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

###########################################################################
########## TEMP TABLES ####################################################
###########################################################################

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
================================================
 TEMP TABLES: **INTO** 
================================================
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

Temp tables are a more fexible and powerful alternative to CTEs. 
Temp tables, instead of being limited by the scope of the current
query, are only limited by the current session. 


LIMITATIONS OF CTEs:
> CTEs can only be used in the current query scope, meaning 
  they cannot be referenced after the final SELECT.

> This can be a problem if you need to reuse your virtual
  tables multiple times for different purposes. 

> Virtual tables cannot be referenced individually, making 
  debugging more difficult.

> Certain optimization techniques are not available 
  to CTEs.


USE TMEP TABLES WHEN:
> You need to reference one of your virtual tables in 
  multiple outputs

> You need to join massive datasets in your virtual tables

> You need a "script" instead of a query: a bundle of SQL
  statement that does more than returning a single output.


>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

SELECT 
       OrderDate
	  ,OrderMonth = DATEFROMPARTS(YEAR(OrderDate),MONTH(OrderDate),1)
      ,TotalDue
	  ,OrderRank = ROW_NUMBER() OVER(PARTITION BY DATEFROMPARTS(YEAR(OrderDate),MONTH(OrderDate),1) ORDER BY TotalDue DESC)

INTO #Sales -- Keyword and temp table name

FROM AdventureWorks2019.Sales.SalesOrderHeader


SELECT
	OrderMonth,
	Top10Total = SUM(TotalDue)

INTO #Top10Sales

FROM #Sales

WHERE OrderRank <= 10

GROUP BY OrderMonth



SELECT
	A.OrderMonth,
	A.Top10Total,
	PrevTop10Total = B.Top10Total

FROM #Top10Sales A
	LEFT JOIN #Top10Sales B
		ON A.OrderMonth = DATEADD(MONTH,1,B.OrderMonth)

ORDER BY 1

SELECT * FROM #Sales WHERE OrderRank <= 5;

SELECT * FROM #Sales WHERE OrderRank <= 10;

-- Drop temp tables to recreates them
-- It's good practice to drop your temp tables at the 
-- end of your code because they do take up mememory
-- in the SQL servers.
DROP TABLE #Sales
DROP TABLE #Top10Sales

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
================================================
 CREATE & INSERT TEMP TABLES
================================================
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

For more explicit control over your tables. 
And for increased optimization. 

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
/* CREATE and INSERT TEMP TABLES*/

-- Creates an empty table
CREATE TABLE #Sales
(
       OrderDate DATE
	  ,OrderMonth DATE
      ,TotalDue MONEY
	  ,OrderRank INT
)

-- Insert data into the newly created temp table
INSERT INTO #Sales
(
       OrderDate
	  ,OrderMonth
      ,TotalDue
	  ,OrderRank
)
SELECT 
       OrderDate
	  ,OrderMonth = DATEFROMPARTS(YEAR(OrderDate),MONTH(OrderDate),1)
      ,TotalDue
	  ,OrderRank = ROW_NUMBER() OVER(PARTITION BY DATEFROMPARTS(YEAR(OrderDate),MONTH(OrderDate),1) ORDER BY TotalDue DESC)

FROM AdventureWorks2019.Sales.SalesOrderHeader



CREATE TABLE #Top10Sales
(
OrderMonth DATE,
Top10Total MONEY
)

-- NOT RECOMENDED: Without parentheses
-- SQL assumes that order and the columns
-- in the CREATE TABLE statement

INSERT INTO #Top10Sales

SELECT
OrderMonth,
Top10Total = SUM(TotalDue)

FROM #Sales
WHERE OrderRank <= 10
GROUP BY OrderMonth



SELECT
A.OrderMonth,
A.Top10Total,
PrevTop10Total = B.Top10Total

FROM #Top10Sales A
	LEFT JOIN #Top10Sales B
		ON A.OrderMonth = DATEADD(MONTH,1,B.OrderMonth)

ORDER BY 1

SELECT * FROM #Sales WHERE OrderRank <= 10

DROP TABLE #Sales
DROP TABLE #Top10Sales
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
================================================
 TRUNCATE TABLE
================================================
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

For clearing and reusing tables to streamline and 
optimize your code.

Truncate is useful to clear out and reuse temp tables, 
especially in cases where you have data coming from 
different sources that nonetheless is structured similarly.

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

/*Whole point of this exercise is to not create
unnecessary redundant temp tables.*/

-- The temp table created must have the same structure (columns and types)
-- for all the populated temp tables that follows. 

CREATE TABLE #Orders
(
       OrderDate DATE
	  ,OrderMonth DATE
      ,TotalDue MONEY
	  ,OrderRank INT
)


-- handle the Sales data and the Purchases data
-- one at the time to avoid duplicates
INSERT INTO #Orders
(
       OrderDate
	  ,OrderMonth
      ,TotalDue
	  ,OrderRank
)
SELECT 
       OrderDate
	  ,OrderMonth = DATEFROMPARTS(YEAR(OrderDate),MONTH(OrderDate),1)
      ,TotalDue
	  ,OrderRank = ROW_NUMBER() OVER(PARTITION BY DATEFROMPARTS(YEAR(OrderDate),MONTH(OrderDate),1) ORDER BY TotalDue DESC)

FROM AdventureWorks2019.Sales.SalesOrderHeader



CREATE TABLE #Top10Orders
(
OrderMonth DATE,
OrderType VARCHAR(32),
Top10Total MONEY
)


INSERT INTO #Top10Orders
(
OrderMonth,
OrderType,
Top10Total
)
SELECT
OrderMonth,
OrderType = 'Sales', -- distinguish between Sales and Purchases
Top10Total = SUM(TotalDue)

FROM #Orders
WHERE OrderRank <= 10
GROUP BY OrderMonth


/*Fun part begins here*/
-- Empty the Orders temp data.
-- And pupulate the Orders temp table with the Purchases data instead of Sales data.
TRUNCATE TABLE #Orders

INSERT INTO #Orders
(
       OrderDate
	  ,OrderMonth
      ,TotalDue
	  ,OrderRank
)
SELECT 
       OrderDate
	  ,OrderMonth = DATEFROMPARTS(YEAR(OrderDate),MONTH(OrderDate),1)
      ,TotalDue
	  ,OrderRank = ROW_NUMBER() OVER(PARTITION BY DATEFROMPARTS(YEAR(OrderDate),MONTH(OrderDate),1) ORDER BY TotalDue DESC)

FROM AdventureWorks2019.Purchasing.PurchaseOrderHeader

-- add the Purchase data together with the Sales data
INSERT INTO #Top10Orders
(
OrderMonth,
OrderType,
Top10Total
)
SELECT
OrderMonth,
OrderType = 'Purchase',
Top10Total = SUM(TotalDue)

FROM #Orders
WHERE OrderRank <= 10
GROUP BY OrderMonth


SELECT
A.OrderMonth,
A.OrderType,
A.Top10Total,
PrevTop10Total = B.Top10Total

FROM #Top10Orders A
	LEFT JOIN #Top10Orders B
		ON A.OrderMonth = DATEADD(MONTH,1,B.OrderMonth)
			AND A.OrderType = B.OrderType

ORDER BY 1, 2

DROP TABLE #Orders
DROP TABLE #Top10Orders

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
================================================
 *UPDATE* [temp_table]
 *SET* [variables]
================================================
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

UPDATE statement allows you to modify a table in place,
by updating specified fields.

The UPDATE statements can be extremely useful in cases 
where you need to build on serveral layers of derived 
logic in which each layer references the previous layer.

It also play a key role in optimizing our queries, 
especially when they involve joining extremely large 
data sets together.
 
 >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
CREATE TABLE #SalesOrders
(
 SalesOrderID INT,
 OrderDate DATE,
 TaxAmt MONEY,
 Freight MONEY,
 TotalDue MONEY,
 TaxFreightPercent FLOAT,
 TaxFreightBucket VARCHAR(32),
 OrderAmtBucket VARCHAR(32),
 OrderCategory VARCHAR(32),
 OrderSubcategory VARCHAR(32)
)

INSERT INTO #SalesOrders
(
 SalesOrderID,
 OrderDate,
 TaxAmt,
 Freight,
 TotalDue,
 OrderCategory
)

SELECT
 SalesOrderID,
 OrderDate,
 TaxAmt,
 Freight,
 TotalDue,
 OrderCategory = 'Non-holiday Order'

FROM [AdventureWorks2019].[Sales].[SalesOrderHeader]

WHERE YEAR(OrderDate) = 2013

-- Populate our tax rate percentage field.
-- using the UPDATE statement
-- to populate multiple variables.

UPDATE #SalesOrders
SET 
TaxFreightPercent = (TaxAmt + Freight)/TotalDue,
OrderAmtBucket = 
	CASE
		WHEN TotalDue < 100 THEN 'Small'
		WHEN TotalDue < 1000 THEN 'Medium'
		ELSE 'Large'
	END

-- Update a column by using the result of a previous 
-- UPDATE statement.

UPDATE #SalesOrders
SET TaxFreightBucket = 
	CASE
		WHEN TaxFreightPercent < 0.1 THEN 'Small'
		WHEN TaxFreightPercent < 0.2 THEN 'Medium'
		ELSE 'Large'
	END

-- We can apply criteria to our update statements
-- to limit the records we're modifying.

UPDATE #SalesOrders
SET  OrderCategory = 'Holiday'
FROM #SalesOrders
WHERE DATEPART(QUARTER,OrderDate) = 4


DROP TABLE #SalesOrders

 <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
================================================
 *DELETE*
  FROM {Tmp_Tbl | tbl}
  WHERE <condition>
================================================
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

DELETE statement to purge targetd records from our data.

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

--Using DELETE with criteria

INSERT INTO #Sales

SELECT 
       OrderDate
	  ,OrderMonth = DATEFROMPARTS(YEAR(OrderDate),MONTH(OrderDate),1)
      ,TotalDue
	  ,OrderRank = ROW_NUMBER() OVER(PARTITION BY DATEFROMPARTS(YEAR(OrderDate),MONTH(OrderDate),1) ORDER BY TotalDue DESC)

FROM AdventureWorks2019.Sales.SalesOrderHeader


SELECT * FROM #Sales


DELETE FROM #Sales WHERE OrderRank > 10



SELECT
*
FROM #Sales


DROP TABLE #Sales

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

############################################################################
########## OPTIMIZATION ####################################################
############################################################################

JOINs against or between very large tables (millions rows tables) 
slow queries down the most.

What can we do about it?
> Define a filtered dataset as early as possible in our prcess, 
  so we can JOIN additional tables to a smaller core population
  that we care about.

> Avoid several JOINs in a single SELECT query, especially those  
  involving large tables.

> Instead, use UPDATE statements to populate fields in a temp table,
  one source table at a time since the update statement will just 
  grab the first matching value it finds without scanning the entire
  table. 

> Apply indexes to fileds that will be used in JOINs. 
  Indexes are construct in SQL that makes looking up data in a 
  table faster by applying indexes to fields in our temp tables
  that will later be used in joins.

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
================================================
 Using UPDATE statements as an alternative to JOINs
================================================
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

Only when a SELECT query with JOINs is taking a long time to run,
consider the following UPDATE statement to run faster. 

Use only one JOIN statement at time for the INSERT INTO 
and following UPDATE statements.

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
--Starter Code:

SELECT 
	   A.SalesOrderID
	  ,A.OrderDate
      ,B.ProductID
      ,B.LineTotal
	  ,C.[Name] AS ProductName
	  ,D.[Name] AS ProductSubcategory
	  ,E.[Name] AS ProductCategory


FROM AdventureWorks2019.Sales.SalesOrderHeader A
	JOIN AdventureWorks2019.Sales.SalesOrderDetail B
		ON A.SalesOrderID = B.SalesOrderID
	JOIN AdventureWorks2019.Production.Product C
		ON B.ProductID = C.ProductID
	JOIN AdventureWorks2019.Production.ProductSubcategory D
		ON C.ProductSubcategoryID = D.ProductSubcategoryID
	JOIN AdventureWorks2019.Production.ProductCategory E
		ON D.ProductCategoryID = E.ProductCategoryID

WHERE YEAR(A.OrderDate) = 2012 -- limiting condition


--Optimized script


--1.) Create filtered temp table of sales order header table WHERE year = 2012
-- Filtered dataset to a smaller core population that we care about.

CREATE TABLE #Sales2012 
(
SalesOrderID INT,
OrderDate DATE
)

INSERT INTO #Sales2012
(
SalesOrderID,
OrderDate
)

SELECT
SalesOrderID,
OrderDate

FROM AdventureWorks2019.Sales.SalesOrderHeader

WHERE YEAR(OrderDate) = 2012




--2.) Create new temp table after joining in SalesOrderDetail table

CREATE TABLE #ProductsSold2012
(
SalesOrderID INT,
OrderDate DATE,
LineTotal MONEY,
ProductID INT,
ProductName VARCHAR(64),
-- Fields needed in the temp table so that 
-- I can join my temp table out to some other table.
ProductSubcategoryID INT, 
ProductSubcategory VARCHAR(64),
-- Fields needed in the temp table so that 
-- I can join my temp table out to some other table.
ProductCategoryID INT,
ProductCategory VARCHAR(64)
)

INSERT INTO #ProductsSold2012
(
SalesOrderID,
OrderDate,
LineTotal,
ProductID
)

SELECT 
	   A.SalesOrderID
	  ,A.OrderDate
      ,B.LineTotal
      ,B.ProductID


FROM #Sales2012 A
	JOIN AdventureWorks2019.Sales.SalesOrderDetail B
		ON A.SalesOrderID = B.SalesOrderID



--3.) Add product data with UPDATE
-- Populate the remaining fields by UPDATE statements.

UPDATE A
SET
ProductName = B.[Name],
ProductSubcategoryID = B.ProductSubcategoryID

FROM #ProductsSold2012 A
	JOIN AdventureWorks2019.Production.Product B
		ON A.ProductID = B.ProductID



--4.) Add product subcategory with UPDATE

UPDATE A
SET
ProductSubcategory= B.[Name],
ProductCategoryID = B.ProductCategoryID

FROM #ProductsSold2012 A
	JOIN AdventureWorks2019.Production.ProductSubcategory B
		ON A.ProductSubcategoryID = B.ProductSubcategoryID





--5.) Add product category data with UPDATE


UPDATE A
SET
ProductCategory= B.[Name]

FROM #ProductsSold2012 A
	JOIN AdventureWorks2019.Production.ProductCategory B
		ON A.ProductCategoryID = B.ProductCategoryID


SELECT * FROM #ProductsSold2012

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
================================================
 Using UPDATE statements as an alternative to EXISTS
================================================
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

It has the added ability to pull in the actual matching value. 

Using an update, there is no possibility of our data being 
duplicated. Since, a row will be updated with at 
most information from a single line item.


>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
--Select all orders with at least one item over 10K, using EXISTS

/*we have a query that selects all sales orders where there 
is at least a single associated line item from the sales order 
detail table with a line total greater than $10,000.*/

SELECT
       A.SalesOrderID
      ,A.OrderDate
      ,A.TotalDue

FROM AdventureWorks2019.Sales.SalesOrderHeader A

WHERE EXISTS (
	SELECT
	1
	FROM AdventureWorks2019.Sales.SalesOrderDetail B
	WHERE A.SalesOrderID = B.SalesOrderID
		AND B.LineTotal > 10000
)

ORDER BY 1



--5.) Select all orders with at least one item over 10K, including a line item value, using UPDATE

--Create a table with Sales data, including a field for line total:
CREATE TABLE #Sales
(
SalesOrderID INT,
OrderDate DATE,
TotalDue MONEY,
LineTotal MONEY
)


--Insert sales data to temp table
INSERT INTO #Sales
(
SalesOrderID,
OrderDate,
TotalDue
)

SELECT
SalesOrderID,
OrderDate,
TotalDue

FROM AdventureWorks2019.Sales.SalesOrderHeader


--Update temp table with > 10K line totals
/* using an update, there is no possibility of our sales order 
data being duplicated. A single order will be updated with at 
most information from a single line item.*/

UPDATE A
SET LineTotal = B.LineTotal

FROM #Sales A
	JOIN AdventureWorks2019.Sales.SalesOrderDetail B
		ON A.SalesOrderID = B.SalesOrderID

-- Apply criteria to our update
-- Only sales orders that have an associated line item
-- with a line total greater than $10000 should be updated.

WHERE B.LineTotal > 10000

SELECT * FROM #Sales

--Recreate EXISTS:

SELECT * FROM #Sales WHERE LineTotal IS NOT NULL


--Recreate NOT EXISTS:

SELECT * FROM #Sales WHERE LineTotal IS NULL
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<