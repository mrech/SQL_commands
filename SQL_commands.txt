###########################################
########## ADVANCED SQL COMMANDS ##########
###########################################

- EXTRACT: a sub-component of a data type colum
    SELECT EXTRACT({YEAR|MONTH|DAY|WEEK|QUARTER} FROM date_col)
    FROM table
- AGE: return the current age of a timestamp type colum
    SELECT AGE(data_col)
    FROM table
- TO_CHAR: covert data type colum to a specified text formatting
    SELECT TO_CHAR(data_col, 'dd-mm-yyyy')
    FROM table

#############################################
########## CONDITIONAL EXPRESSIONS ##########
#############################################

- CASE: correspond to the IF/ELSE statements
    SELECT col_condition
    CASE 
        WHEN (condition_1) THAN result_1
        WHEN (condition_2) THAN result_2
        ...
        ELSE other_result
    END AS col_name
    FROM table
    
    :: CASE expression variant: evaluate the single value for equality
    SELECT
    SUM(CASE {expression|col_name}
            WHEN n THAN 1
            ELSE 0
        END) AS col_name
    FROM table

    --------------------------
    E.G.:
    SUM(CASE rental_rate
            WHEN 0.99 THAN 1
            ELSE 0
        END) AS bargains
    --------------------------
- COALESCE: replace NULL with the desired value. 
    SELECT (col_1 - COALESCE(col_2,0))
    FROM table
- CAST: convert from one data type into another
    SELECT CAST('5' AS INTEGER)
    FROM table
- NULLIF: NULLIF(arg_1, arg_2) return NULL if arg_1 = arg_2 otherwise arg_1
NB.: useful to return NULL if the denominator is equal to 0 in a division
    SELECT (col_1 / NULLIF(col_2, 0)) AS some_ratio
    FROM table

################################
########## PROCEDURES ##########
################################

- VIEW: is a database object (virtual table - does not store data pysically only the query)
It a combination of tables and conditions used quite often.
+ You can also also alter and update existing views
    
    :: to create a view ...
    CREATE VIEW view_name AS
    --- the query ---
    SELECT columns
    FROM table
    ...

    :: to call it afterwards ...
    SELECT *
    FROM view_name

    :: to modify it ...
    CREATE OR REPLACE VIEW view_name AS
    --- the new query ---
    SELECT columns
    FROM table
    ...

    :: to remove a view ...
    DROP VIEW view_name
    DROP VIEW IF EXISTS view_name

    :: rename the view ...
    ALTER VIEW view_name RENAME TO new_view_name

######################################
########## WINDOW FUNCTIONS ##########
######################################

Window functions allow you to include aggregate calculations in your
queries, WITHOUT otherwise changing the output in any way.

The aggregate calculation is simple tacked on to the query as and
additional column.

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
================================================
  AGGREGATE FUN([column]) **OVER()**
================================================
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

--YTD Sales Via Aggregate Query:

SELECT

      [Total YTD Sales] = SUM(SalesYTD)
      ,[Max YTD Sales] = MAX(SalesYTD)

FROM AdventureWorks2019.Sales.SalesPerson



--YTD Sales With OVER:

SELECT BusinessEntityID
      ,TerritoryID
      ,SalesQuota
      ,Bonus
      ,CommissionPct
      ,SalesYTD
	  ,SalesLastYear
      ,[Total YTD Sales] = SUM(SalesYTD) OVER()
      ,[Max YTD Sales] = MAX(SalesYTD) OVER()
      ,[% of Best Performer] = SalesYTD/MAX(SalesYTD) OVER()

FROM AdventureWorks2019.Sales.SalesPerson

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
================================================
  OVER(**PARTITION BY** [column|s]) 
================================================
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

It is possible to group these calculations, just like we can with 
aggregate queries, using PARTITION.

PARTITION BY allows us to compute aggregate totals for groups
within our data, while still retaining row-level detail

PARTITION BY assign each row of your query output to a group,
without collapsing your data into fewer rows as with GROUP BY


>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

--Sum of line totals, grouped by ProductID AND OrderQty, in an aggregate query

SELECT
	ProductID,
	OrderQty,
	LineTotal = SUM(LineTotal)

FROM AdventureWorks2019.Sales.SalesOrderDetail

GROUP BY
	ProductID,
	OrderQty

ORDER BY 1,2 DESC



--Sum of line totals via OVER with PARTITION BY

SELECT
	ProductID,
	SalesOrderID,
	SalesOrderDetailID,
	OrderQty,
	UnitPrice,
	UnitPriceDiscount,
	LineTotal,
	ProductIDLineTotal = SUM(LineTotal) OVER(PARTITION BY ProductID, OrderQty)

FROM AdventureWorks2019.Sales.SalesOrderDetail

ORDER BY ProductID, OrderQty DESC

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
================================================
  **ROW_NUMBER()** OVER(PARTITION BY [column|s] ORDER BY [column|s])
================================================
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

ROW_NUMBER() give us the ability to rank records within our data.

These ranking can either be applied across the entire query output, 
or to partitioned groups within it. 

It uses brute force to deal with ties returning always a unique 
sequencial series of ranking. 

If you are trying to pick exactly one record from each partition
group - either the first or last - use ROW_NUMBER()


>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

--Ranking all records within each group of sales order IDs

SELECT
	SalesOrderID,
	SalesOrderDetailID,
	LineTotal,
	ProductIDLineTotal = SUM(LineTotal) OVER(PARTITION BY SalesOrderID),
	Ranking = ROW_NUMBER() OVER(PARTITION BY SalesOrderID ORDER BY LineTotal DESC)

FROM AdventureWorks2019.Sales.SalesOrderDetail

ORDER BY
SalesOrderID




--Ranking ALL records by line total - no groups!

SELECT
	SalesOrderID,
	SalesOrderDetailID,
	LineTotal,
	ProductIDLineTotal = SUM(LineTotal) OVER(PARTITION BY SalesOrderID),
	Ranking = ROW_NUMBER() OVER(ORDER BY LineTotal DESC)

FROM AdventureWorks2019.Sales.SalesOrderDetail

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
================================================
  **RANK()** OVER(PARTITION BY [column|s] ORDER BY [column|s])      
  **DENSE_RANK()** OVER(PARTITION BY [column|s] ORDER BY [column|s]) 
================================================
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

RANK() assign the same rank for ties and skip the sequence ahead based
on how many ties there are. So, the next number in the sequence is a 
reflection of that number position in the partition group. 

DENSE_RANK() if you want ties to be explicitly identified without having breaks 
within the sequence of ranking.

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

--ROW_NUMBER, RANK, AND DENSE_RANK, compared

SELECT
	SalesOrderID,
	SalesOrderDetailID,
	LineTotal,
	Ranking = ROW_NUMBER() OVER(PARTITION BY SalesOrderID ORDER BY LineTotal DESC),
	RankingWithRank = RANK() OVER(PARTITION BY SalesOrderID ORDER BY LineTotal DESC),
	RankingWithDenseRank = DENSE_RANK() OVER(PARTITION BY SalesOrderID ORDER BY LineTotal DESC)

FROM AdventureWorks2019.Sales.SalesOrderDetail

ORDER BY SalesOrderID, LineTotal DESC

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
================================================
 **LEAD([column], [n])** OVER(PARTITION BY [column|s] ORDER BY [column|s])
 **LAG([column], [n])** OVER(PARTITION BY [column|s] ORDER BY [column|s])
================================================
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

LEAD and LAG let us grab values from subsequent or previous
records relative to the position of the "current" record in 
our data. 

They can be useful any time we want to compare a value in a given 
column to the next or previous value in the same column - but side by side, in the same row.


>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

--Basic LEAD/LAG example

SELECT
       SalesOrderID
      ,OrderDate
      ,CustomerID
      ,TotalDue
	  ,NextTotalDue = LEAD(TotalDue, 3) OVER(ORDER BY SalesOrderID)
	  ,PrevTotalDue = LAG(TotalDue, 3) OVER(ORDER BY SalesOrderID)

FROM AdventureWorks2019.Sales.SalesOrderHeader

ORDER BY SalesOrderID




--Looking forward (or backward) more than one record

SELECT
       SalesOrderID
      ,OrderDate
      ,CustomerID
      ,TotalDue
	  ,NextTotalDue = LEAD(TotalDue, 3) OVER(ORDER BY SalesOrderID)
	  ,PrevTotalDue = LAG(TotalDue, 3) OVER(ORDER BY SalesOrderID)

FROM AdventureWorks2019.Sales.SalesOrderHeader

ORDER BY SalesOrderID





--Using PARTITION with LEAD and LAG

SELECT
       SalesOrderID
      ,OrderDate
      ,CustomerID
      ,TotalDue
	  ,NextTotalDue = LEAD(TotalDue, 1) OVER(PARTITION BY CustomerID ORDER BY SalesOrderID)
	  ,PrevTotalDue = LAG(TotalDue, 1) OVER(PARTITION BY CustomerID ORDER BY SalesOrderID)

FROM AdventureWorks2019.Sales.SalesOrderHeader

ORDER BY CustomerID, SalesOrderID

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
================================================
 **FIRST_VALUE([column])** OVER(PARTITION BY [column|s] ORDER BY [column|s])
================================================
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

Operates over a window of rows defined by a PARTITION BY clause.
Returns the *first value* from the specified column within that window.
Useful for comparing the values in each row of a window with the first one.

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

--Highest and lowest line totals per customer

SELECT
	SalesOrderID,
	SalesOrderDetailID,
	LineTotal,
	Ranking = ROW_NUMBER() OVER(PARTITION BY SalesOrderID ORDER BY LineTotal DESC),
	HighestTotal = FIRST_VALUE(LineTotal) OVER(PARTITION BY SalesOrderID ORDER BY LineTotal DESC),
	LowestTotal = FIRST_VALUE(LineTotal) OVER(PARTITION BY SalesOrderID ORDER BY LineTotal)

FROM AdventureWorks2019.Sales.SalesOrderDetail

ORDER BY
	SalesOrderID, LineTotal DESC




--First/oldest order per customer

SELECT 
	CustomerID,
	OrderDate,
	TotalDue,
	FirstOrderAmt = FIRST_VALUE(TotalDue) OVER(PARTITION BY CustomerID ORDER BY OrderDate)
 
FROM AdventureWorks2019.Sales.SalesOrderHeader

ORDER BY CustomerID, OrderDate

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
================================================
 SUBQUERIES WITHIN THE FROM CLUASE
================================================
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

Subqueries are best for straightforward, two-step queries.

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

--Selecting the most expensive item per order in a single query

SELECT
*
FROM
    (
    SELECT
    SalesOrderID,
    SalesOrderDetailID,
    LineTotal,
    LineTotalRanking = ROW_NUMBER() OVER(PARTITION BY SalesOrderID ORDER BY LineTotal DESC)

    FROM AdventureWorks2019.Sales.SalesOrderDetail

) A -- subqueries from the FORM clause requires an ALIAS

WHERE LineTotalRanking = 1

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
================================================
 SCALAR SUBQUERIES
================================================
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

Use them any time you want to include aggregate calculations directly in the WHERE clause.

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

--Example 1: Scalar values

SELECT
	MAX(ListPrice)
FROM AdventureWorks2019.Production.Product

SELECT
	AVG(ListPrice)
FROM AdventureWorks2019.Production.Product




--Example 2: Scalar subqueries in the SELECT and WHERE clauses

SELECT 
	   ProductID
      ,[Name]
      ,StandardCost
      ,ListPrice
	  ,AvgListPrice = (SELECT AVG(ListPrice) FROM AdventureWorks2019.Production.Product)
	  ,AvgListPriceDiff = ListPrice - (SELECT AVG(ListPrice) FROM AdventureWorks2019.Production.Product)

FROM AdventureWorks2019.Production.Product

WHERE ListPrice > (SELECT AVG(ListPrice) FROM AdventureWorks2019.Production.Product)

ORDER BY ListPrice ASC

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
================================================
 CORRELATED SUBQUERIES
================================================
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

Correlated subqueries are subqueries that run once for each record in the main/outer query.
They then return a scalar output for each of those records.
Correlated subqueries can be used in either the SELECT and WHERE clauses. 

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
SELECT 
       SalesOrderID
      ,OrderDate
      ,SubTotal
      ,TaxAmt
      ,Freight
      ,TotalDue
	  ,MultiOrderCount = --correlated subquery
	  (
		  SELECT
		  COUNT(*)
		  FROM AdventureWorks2019.Sales.SalesOrderDetail B
		  WHERE A.SalesOrderID = B.SalesOrderID
		  AND B.OrderQty > 1
	  )

  FROM AdventureWorks2019.Sales.SalesOrderHeader A
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<


@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
================================================
  AGGREGATE FUN([column]) OVER(ODER BY [column|s] **ROWS BETWEEN [n] PRECEDING AND CURRENT ROW**)
  AGGREGATE FUN([column]) OVER(ODER BY [column|s] **ROWS BETWEEN [n] PRECEDING AND [n] PRECEDING**)
  AGGREGATE FUN([column]) OVER(ODER BY [column|s] **ROWS BETWEEN [n] PRECEDING AND [n] FOLLOWING**)
================================================
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

Moving averages are used frequently because they are good at
smoothing out short term fluctuations in the overall trend of
our data. Making it easy to identify patterns and overall trends.


>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

/*Rolling 3 day total*/

SELECT
    OrderDate,
    TotalDue,
	SalesLast3Days = SUM(TotalDue) OVER(ORDER BY OrderDate ROWS BETWEEN 2 PRECEDING AND CURRENT ROW)
FROM (
	SELECT
		OrderDate,
		TotalDue = SUM(TotalDue)
	FROM
		Sales.SalesOrderHeader

	WHERE YEAR(OrderDate) = 2014

	GROUP BY
		OrderDate
) X

ORDER BY
    OrderDate



/*Rolling 3 day total, not inclusive of "current" row*/


SELECT
    OrderDate,
    TotalDue,
	SalesLast3Days = SUM(TotalDue) OVER(ORDER BY OrderDate ROWS BETWEEN 3 PRECEDING AND 1 PRECEDING)
FROM (
	SELECT
		OrderDate,
		TotalDue = SUM(TotalDue)
	FROM
		Sales.SalesOrderHeader

	WHERE YEAR(OrderDate) = 2014

	GROUP BY
		OrderDate
) X

ORDER BY
    OrderDate


/*Rolling 3 day total, spanning previous and following row*/


SELECT
    OrderDate,
    TotalDue,
	SalesLast3Days = SUM(TotalDue) OVER(ORDER BY OrderDate ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING)
FROM (
	SELECT
		OrderDate,
		TotalDue = SUM(TotalDue)
	FROM
		Sales.SalesOrderHeader

	WHERE YEAR(OrderDate) = 2014

	GROUP BY
		OrderDate
) X

ORDER BY
    OrderDate



/*Rolling 3 day average - aka, a "moving" average*/


SELECT
    OrderDate,
    TotalDue,
	SalesLast3Days = AVG(TotalDue) OVER(ORDER BY OrderDate ROWS BETWEEN 2 PRECEDING AND CURRENT ROW)
FROM (
	SELECT
		OrderDate,
		TotalDue = SUM(TotalDue)
	FROM
		Sales.SalesOrderHeader

	WHERE YEAR(OrderDate) = 2014

	GROUP BY
		OrderDate
) X

ORDER BY
    OrderDate


<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
================================================
  EXISTS & NOT EXISTS SUBQUERY
================================================
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

EXISTS: checks to see if a match according to whatever criteria
we've set exists in another table, but it doesn't particularly 
care which record matches or how many matches there are.



For one-to-one relationships, there really isn't much of
an advantage to using EXISTS over JOIN.
However, EXISTS offers some powerful advantages when dealing
with one-to-many relationships.

Useful to apply criteria to fields from a secondary table,
but don't need to include those fields in your output.

You want to apply criteria to fields from a secondary table,
while ensuring that multiple matches in the secondary table won't
duplicate data from the primary table in your output.

You need to check a secondary table to make sure a match of
some type does NOT exist.

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

--Example 1 with one-to-many relationships

SELECT * FROM AdventureWorks2019.Sales.SalesOrderHeader WHERE SalesOrderID = 43683;

SELECT * FROM AdventureWorks2019.Sales.SalesOrderDetail WHERE SalesOrderID = 43683;

-- Example of a order without a line of at least 10.000$
SELECT * FROM AdventureWorks2019.Sales.SalesOrderDetail WHERE SalesOrderID = 43659;



--Example 2: One to many with JOIN criteria
/*
Here, we want to see all customer orders that have at least one item with 
a line total of 10.000$. However, we do not want to get to the specific item within that order. 
*/

SELECT
       A.SalesOrderID
      ,A.OrderDate
      ,A.TotalDue

FROM AdventureWorks2019.Sales.SalesOrderHeader A
	INNER JOIN AdventureWorks2019.Sales.SalesOrderDetail B
		ON A.SalesOrderID = B.SalesOrderID

WHERE B.LineTotal > 10000

ORDER BY A.SalesOrderID

-- The ABOVE solution creates unwated duplicates



--Example 3: Using EXISTS to pick only the records we need

SELECT
       A.SalesOrderID
      ,A.OrderDate
      ,A.TotalDue

FROM AdventureWorks2019.Sales.SalesOrderHeader A

WHERE EXISTS (  -- return nothing. Just check the existance of a record in another table
	SELECT -- here, you can put whatever you want
	1
	FROM AdventureWorks2019.Sales.SalesOrderDetail B
	WHERE A.SalesOrderID = B.SalesOrderID -- correlated subqueries
		AND B.LineTotal > 10000
)

-- AND A.SalesOrderID = 43659 -- To check if indeed orders without items of at least 10.000$ aren't within the output table

ORDER BY A.SalesOrderID



--Example 4: Get the opposite in a one-to-many relationships context
-- using the JOIN critiria
/*
Here, we want to see all customer orders without items with 
a line total of 10.000$. However, we do not want to get to the specific item within that order. 
*/

SELECT
       A.SalesOrderID
      ,A.OrderDate
      ,A.TotalDue
	  ,B.SalesOrderDetailID
	  ,B.LineTotal

FROM AdventureWorks2019.Sales.SalesOrderHeader A
	INNER JOIN AdventureWorks2019.Sales.SalesOrderDetail B
		ON A.SalesOrderID = B.SalesOrderID

WHERE B.LineTotal < 10000
	AND A.SalesOrderID = 43683

ORDER BY A.SalesOrderID

-- The ABOVE solution doesn't even do what we want!
-- It returns all items within a order that are less than or equal to $10.000


SELECT
*
FROM AdventureWorks2019.Sales.SalesOrderDetail

WHERE SalesOrderID = 43683

ORDER BY LineTotal DESC




--Example 6: NOT EXISTS
/*
Here, we want to see all customer orders without items with 
a line total of 10.000$. However, we do not want to get to the specific item within that order. 
*/

SELECT
       A.SalesOrderID
      ,A.OrderDate
      ,A.TotalDue

FROM AdventureWorks2019.Sales.SalesOrderHeader A

WHERE NOT EXISTS ( -- kicks the record out if exists
	SELECT
	1
	FROM AdventureWorks2019.Sales.SalesOrderDetail B
	WHERE A.SalesOrderID = B.SalesOrderID
		AND B.LineTotal > 10000
)
-- AND A.SalesOrderID = 43683 -- To check if indeed orders with items greater of 10.000$ aren't within the output table

ORDER BY A.SalesOrderID

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<