########## ADVANCED SQL COMMANDS ##########
- EXTRACT: a sub-component of a data type colum
    SELECT EXTRACT({YEAR|MONTH|DAY|WEEK|QUARTER} FROM date_col)
    FROM table
- AGE: return the current age of a timestamp type colum
    SELECT AGE(data_col)
    FROM table
- TO_CHAR: covert data type colum to a specified text formatting
    SELECT TO_CHAR(data_col, 'dd-mm-yyyy')
    FROM table


########## CONDITIONAL EXPRESSIONS ##########
- CASE: correspond to the IF/ELSE statements
    SELECT col_condition
    CASE 
        WHEN (condition_1) THAN result_1
        WHEN (condition_2) THAN result_2
        ...
        ELSE other_result
    END AS col_name
    FROM table
    
    :: CASE expression variant: evaluate the single value for equality
    SELECT
    SUM(CASE {expression|col_name}
            WHEN n THAN 1
            ELSE 0
        END) AS col_name
    FROM table
- COALESCE: replace NULL with the desired value. 
    SELECT (col_1 - COALESCE(col_2,0))
    FROM table
- CAST: convert from one data type into another
    SELECT CAST('5' AS INTEGER)
    FROM table
- NULLIF: NULLIF(arg_1, arg_2) return NULL if arg_1 = arg_2 otherwise arg_1
NB.: useful to return NULL if the denominator is equal to 0 in a division
    SELECT (col_1 / NULLIF(col_2, 0)) AS some_ratio
    FROM table


########## PROCEDURES ##########
- VIEW: is a database object (virtual table - does not store data pysically only the query)
It a combination of tables and conditions used quite often.
+ You can also also alter and update existing views
    
    :: to create a view ...
    CREATE VIEW view_name AS
    --- the query ---
    SELECT columns
    FROM table
    ...

    :: to call it afterwards ...
    SELECT *
    FROM view_name

    :: to modify it ...
    CREATE OR REPLACE VIEW view_name AS
    --- the new query ---
    SELECT columns
    FROM table
    ...

    :: to remove a view ...
    DROP VIEW view_name
    DROP VIEW IF EXISTS view_name

    :: rename the view ...
    ALTER VIEW view_name RENAME TO new_view_name


########## WINDOW FUNCTIONS ##########
Window functions allow you to include aggregate calculations in your
queries, WITHOUT otherwise changing the output in any way.

The aggregate calculation is simple tacked on to the query as and
additional column.

----------------------------------------
AGGREGATE FUN() **OVER()**
----------------------------------------
--YTD Sales Via Aggregate Query:

SELECT

      [Total YTD Sales] = SUM(SalesYTD)
      ,[Max YTD Sales] = MAX(SalesYTD)

FROM AdventureWorks2019.Sales.SalesPerson



--YTD Sales With OVER:

SELECT BusinessEntityID
      ,TerritoryID
      ,SalesQuota
      ,Bonus
      ,CommissionPct
      ,SalesYTD
	  ,SalesLastYear
      ,[Total YTD Sales] = SUM(SalesYTD) OVER()
      ,[Max YTD Sales] = MAX(SalesYTD) OVER()
      ,[% of Best Performer] = SalesYTD/MAX(SalesYTD) OVER()

FROM AdventureWorks2019.Sales.SalesPerson


----------------------------------------
OVER(**PARTITION BY**) 
----------------------------------------
It is possible to group these calculations, just like we can with 
aggregate queries, using PARTITION.

PARTITION BY allows us to compute aggregate totals for groups
within our data, while still retaining row-level detail

PARTITION BY assign each row of your query output to a group,
without collapsing your data into fewer rows as with GROUP BY

--Sum of line totals, grouped by ProductID AND OrderQty, in an aggregate query

SELECT
	ProductID,
	OrderQty,
	LineTotal = SUM(LineTotal)

FROM AdventureWorks2019.Sales.SalesOrderDetail

GROUP BY
	ProductID,
	OrderQty

ORDER BY 1,2 DESC



--Sum of line totals via OVER with PARTITION BY

SELECT
	ProductID,
	SalesOrderID,
	SalesOrderDetailID,
	OrderQty,
	UnitPrice,
	UnitPriceDiscount,
	LineTotal,
	ProductIDLineTotal = SUM(LineTotal) OVER(PARTITION BY ProductID, OrderQty)

FROM AdventureWorks2019.Sales.SalesOrderDetail

ORDER BY ProductID, OrderQty DESC


----------------------------------------
**ROW_NUMBER()** OVER(PARTITION BY ORDER BY)
----------------------------------------
ROW_NUMBER() give us the ability to rank records within our data.

These ranking can either be applied across the entire query output, 
or to partitioned groups within it. 

It uses brute force to deal with ties returning always a sequencial
series of ranking. 


--Ranking all records within each group of sales order IDs

SELECT
	SalesOrderID,
	SalesOrderDetailID,
	LineTotal,
	ProductIDLineTotal = SUM(LineTotal) OVER(PARTITION BY SalesOrderID),
	Ranking = ROW_NUMBER() OVER(PARTITION BY SalesOrderID ORDER BY LineTotal DESC)

FROM AdventureWorks2019.Sales.SalesOrderDetail

ORDER BY
SalesOrderID




--Ranking ALL records by line total - no groups!

SELECT
	SalesOrderID,
	SalesOrderDetailID,
	LineTotal,
	ProductIDLineTotal = SUM(LineTotal) OVER(PARTITION BY SalesOrderID),
	Ranking = ROW_NUMBER() OVER(ORDER BY LineTotal DESC)

FROM AdventureWorks2019.Sales.SalesOrderDetail
